# C++ 程序设计 侯捷

## 01 C++编程简介

基于C++98 (课程录制于2015)

### 良好编程习惯

对于单一类，基于对象object based

1. 带有pointer的类
2. 不带有pointer的类

对于类之间关系，面向对象object orientated

### C++演化

C++语言 & C++标准库，该课程主要介绍C++语言

推荐书籍

1. C++ Primer

2. THE C++ PROGRAMMING LANGUAGE

3. Effective C++

4. THE C++ STANDARD LIBRARY

5. STL源码剖析

## 02 头文件与类声明

C(type)、C++(class,struct)

.h 头文件，标准库。.cpp 主程序，include <标准库.h> "私有.h"

### 头文件中 guard 防范式声明

```c++
#ifndef COMPLEX_HPP
#define COMPLEX_HPP
...
#endif //COMPLEX_HPP
```

代码块

1. 前置声明

2. 类声明

3. 类定义

类模板template

## 03 构造函数

### 声明

内联函数inline，方法定义在类内部默认为inline，而外部需要自己声明。inline实质为建议，具体是否实现取决于编译器

### 访问等级

private私有，public公有，protected保护。避免变量直接访问类成员变量

**建议所有变量均为私有**

### 构造函数

```c++
class complex {
    public:
        complex (double r = 0, double i = 0)
            : re(r), im(i)    // 初值列
        {}
    private:
        double re, im;
};
```

构造函数的默认实参和初值列，初值列为构造函数特性，**建议使用初值列**而避免在函数内部赋值

C++允许重载函数，编译器处理重载函数时视为不同名称的不同函数，只是对用户名称相同。当编译器不一定能找到想要的函数时，会报错

构造函数放在private的特例

```c++
class A { // Singleton 单例
    public:
        static A &getInstance ();
        void step () {}
    private:
        A () {};
        A (const A &rhs){};
};
A &A::getInstance () {
    static A a;
    return a;
}

A::getInstance().step();    // 调用
```

## 04 参数传递和返回值

### 常量成员函数

**const是好文明**，不建议声明了一个const的对象却使用了没有用const修饰的方法

### 参数传递、返回值传递

1. 按值传递

2. 按引用传递（C语言中按指针），**建议所有参数均使用引用**（包括int等）

### 友元

可以直接访问private变量，设计时既可以使用友元也可以使用公有方法

```c++
class complex {
	friend complex &__doapl (complex *, const complex &);
};
inline complex &__doapl (complex *ths, const complex &r) {
    ...
    return *ths;
}
```

但下面这种情况，也可以通过公有方法访问另一个的私有变量。这个现象可以通过相同class的各个对象互为友元来解释

```c++
class complex {
    public:
        double func (const complex &param) { return param.re + param.im; }
};

const complex c1(2);
complex c2(3);
c2.func(c1);
```

什么时候不能返回引用

1. 原本形参已经存在空间（如：形参为指针A *ptr，返回 *ptr）
2. 必须开辟新空间存放结果（生存期过了）

## 05 操作符重载和临时对象

C++中操作符也可以视为一种函数

### 操作符重载-1（成员函数）

```c++
inline complex &complex::operator+= (const complex &r) {
    return __doapl(this, r);
}
inline complex &__doapl (complex *ths, const complex &r) {
    ...
    return *ths;
}

c1 += c2;
c1 += c2 += c3;
```

+= 操作符作用在左侧c1上，又因为是成员函数所以可以使用this

传递者无需知道接收者是以引用形式接收

### 操作符重载-2（非成员函数）

```c++
inline complex operator+ (const complex &x, double y) {
    return complex(real(x) + y, imag(x));
}

c1 = c2 + 1
```

因为这不是成员函数所以不能使用this，而且不能返回引用（局部作用域）

返回的是typename() 临时对象

大多数重载都能使用这两种操作符重载，但对于cout <<这种只能使用非成员函数，因为左侧的操作数不是类本身

## 06 复习Complex类实现

Complex类实现思路

## 07 拷贝构造、拷贝复制和析构

```c++
str s1 ();
str s2("Hello");
str s3(s1); // 拷贝构造
str *s4 = new str("Hello")
s3 = s2;  // 拷贝赋值
```

编译器默认拷贝构造和拷贝复制函数为复制成员变量，但在带有pointer的类，这种方式就不好用了

带有pointer的类建议编写**拷贝构造和拷贝复制函数**（深拷贝）

## 08 堆、栈和内存管理

### 堆、栈


stack 栈，存在于作用域scope的一块内存空间，调用函数时会形成一个栈来放置参数、本地变量和返回地址。

heap 堆，操作系统提供的一块全局空间

```c++
complex global(8, 5);    // 全局对象，也可以看成是静态对象
int memory () {
    complex c1(1, 2);   // 栈，离开作用域死亡
    complex *c2 = new complex(3);   // 堆，任意地方通过new获取全局堆空间
    static complex c3(5, 6); // 静态对象，离开作用域后仍存在，直到程序结束
}
```

### 内存管理

new 被解释为三步操作，先分配内存再构造

```c++
complex *c = new complex(1, 2);

void *m = operator new(sizeof(complex));    // 调用malloc()拿到一块内存
c = static_cast<complex *>(m);  // 转型
c->complex::complex(1, 2);  // 构造函数 实际c->complex::complex(c, 1, 2)
```

delete 被解释为两步操作，先析构再释放内存

```c++
delete s;

str::~str(s);   // 析构函数
operator delete(s); // 释放内存
```

对于类complex在VC调试模式下，通过 new complex

```c++
class complex {
    private:
        double re, im;
};
```

实际占用的内存为：1x4 + 8x4 + 2x4 +  1x4 + 3x4 + 1x4 = 52 + 12 = 64 字节 

1. 1x4 cookie 具体数据：64字节 -> 0x40 最后一位表示内存状态(给出去时) -> 0x41

2. 8x4 debug

3. 2x4 复数

4. 1x4 debug

5. 3x4 内存对齐

6. 1x4 cookie

**new [] 要搭配 delete []**

对于类complex在VC调试模式下，通过 new complex[3]

实际占用的内存为：1x4 + 8x4 + 1x4 + 3x2x4 + 1x4 + 2x4 + 1x4 = 80 字节

1. 1x4 cookie
2. 8x4 debug
3. 1x4 数组长度
4. 3x2x4 复数
5. 1x4 debug
6. 2x4 内存对齐
7. 1x4 cookie

delete [] 会使用数组长度次的析构函数，而 delete 只会调用一次。这里就发生了内存泄漏，而整块空间由于cookie的存在会正常释放

## 09 复习Str类实现

Str类实现思路

## 10 类模板、函数模板和其他

### static 静态

无论是变量还是函数，都可以用static进行修饰，静态的东西只有一份

```c++
complex c1(3, 4), c2(3, 4);
cout << c1.real();
cout << complex::real(&c1);
```

成员函数只有一份，但可以处理很多个对象，靠的就是this指针。相对于python显式的self，c++中的this是隐式的。如果成员函数标识了static，则会丢失this指针

```c++
class Account {
    public:
        static double m_rate;
        static void set_rate (const double &x);
};
double Account::m_rate;   // 静态数据要在类的外面定义

int addon(){
    Account::set_rate(5);   // 通过类调用

    Account b;
    b.set_rate(5);  // 通过对象调用
}
```

### cout

```c++
class ostream: virtual public ios {
    public:
        ostream &operator<< (char c);
    	...
};
```

cout 对各种情况进行了重载

### template 模板

模板会造成代码的膨胀，但这是必要的。模板可以是类、结构体或结构体

```c++
template<typename T>
struct multi {
    T id;
};
multi<int> person;
```

### namespace

```c++
namespace tds {
    
template<typename T>
struct multi {
    T id;
};
multi<int> person;
void add(){}
    
}

namespace dts = tds;
using namespace tds;
using dts::add;
```

命名空间可以包装一些东西

### 其他有待深入的细节

1. operator type() const
2. explict
3. pointer-like object
4. function-like object
5. namespace
6. template specialization
7. standard library
8. C++11新特性

革命尚未成功，同志仍需努力

## 11 组合与继承

继承Inheritance、组合Composition、委托Delegation

### 组合Composition

表示 has-a，下面的代码说明了组合以及Adapter的设计模式

构造由内到外(先构造成员)，析构从外到内

```c++
template<class T>
class queue {
    protected:
        deque<T> a; // 底层容器
    public: // 以下函数完全利用a的操作函数实现
        bool empty () const { return a.empty(); }
        size_type size () const { return a.size(); }
        void pop () { a.pop_front(); }
};

template<class T>
class deque {
    protected:
        Itr<T> start;
        Itr<T> finish;
        T **map;
        unsigned char map_size ();
};

template<class T>
struct Itr {
    T *cur;
    T *first;
    T *last;
    T **node;
};
```

### 委托Delegation

用指针相连，和组合不一样，这两个生命周期不一致

String接口不变，而StringRep无所谓。也可以用于多个对象共用

```c++
class StringRep;

class String {
    public:
        String ();
        String (const char *s);
        String (const String &s);
        ~String ();
    private:
        StringRep *rep; // pimpl (Handle/Body)
};

class StringRep {
        friend class String;
        StringRep (const char *s);
        ~StringRep ();
};
```

### 继承Inheritance

表示is-a

```c++
struct _List_node_bse {
    _List_node_bse *_M_next;
    _List_node_bse *_M_prev;
};

template<typename _Tp>
struct _List_node: public _List_node_bse {
    _Tp _M_data;
};
```

构造由内而外(先调用父类构造)，析构由外而内

## 12 虚函数和多态

non-virtual: 你不希望子类重新定义

virtual: 你希望子类重写定义，且对他有默认定义

pure virtual: 你希望子类一定要重新定义，且无默认定义

```c++
class Shape {
    public:
        virtual void draw () const = 0; // pure virtual
        virtual void error (const std::string &msg); // impure virtual
        int objectID () const; // non-virtual
};

class CDocument {
    public:
        void OnFileOpen ();
        virtual void Serialize ();
};
void CDocument::OnFileOpen () {
    Serialize();
}

class CMyDoc: public CDocument {
    public:
        virtual void Serialize (); // template method设计模式
};

void test () {
    CMyDoc myDoc;
    myDoc.OnFileOpen();
}
```

### 继承Inheritance + 组合Composition

...

### 继承Inheritance + 委托Delegation

经常写UI时，可能遇到

```c++
class Subject;

class Observer {
    public:
        virtual void update (Subject *sub, int value) = 0;
};

class Subject {
        int m_value;
        std::vector<Observer *> m_views;
    public:
        void attach (Observer *obs) {
            m_views.push_back(obs);
        };
        void set_val (int value) {
            m_value = value;
            notify();
        };
        void notify () {
            for (int i = 0 ; i < m_views.size() ; ++i) {
                m_views[i]->update(this, m_value);
            }
        };
};
```

## 13 委托相关设计

Component类实现

```c++
class Component {
        int value;
    public:
        Component (int val) { value = val; }
        virtual void add (Component *) {}
};

class Primitive: public Component {
    public:
        Primitive (int val)
            : Component(val) {}
};

class Composite: public Component {
        std::vector<Component *> c;
    public:
        Composite (int val)
            : Component(val) {}
        void add (Component *elem) {
            c.push_back(elem);
        }
};
```

创建未来的对象，预留预先定义的接口。Prototype

```C++
class Image {
    public:
        static Image *findAndClone ();
    protected:
        virtual Image *clone () = 0;
        static void addPrototype (Image *p);
    private:
        static std::vector<Image *> prototype;
};

class LandSatImage: Image {
    public:
        Image *clone () { return new LandSatImage(1); };
    protected:
        LandSatImage (int i) { id = count++; };
    private:
        static LandSatImage LSAT;
        LandSatImage () { addPrototype(this); };
        int id;
        static int count;
};
```

